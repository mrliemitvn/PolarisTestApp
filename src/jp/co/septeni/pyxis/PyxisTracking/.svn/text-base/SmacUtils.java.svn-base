package jp.co.septeni.smac.SmacTracking;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.net.HttpURLConnection;
import java.net.URL;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.zip.Deflater;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.HttpStatus;
import org.apache.http.NameValuePair;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.HttpHead;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.params.AllClientPNames;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.HttpParams;
import org.apache.http.util.EntityUtils;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.net.Uri;
import android.os.Environment;
import android.os.Process;
import android.text.TextUtils;
import android.util.Log;

public class SmacUtils {

	private String className = this.getClass().getSimpleName();
	private SmacConst smacConst = new SmacConst();

	/**
	 * 基本パラメータのチェック
	 *
	 * @param fromContext
	 * @param fromIntent
	 * @param siteId
	 * @param smacMv
	 * @return
	 */
	protected boolean checkBaseParams(String siteId, String smacMv) {

		/** ################# tracelog 処理開始 ################# */
		SmacUtils.recordLog(className,
				(new Throwable()).getStackTrace()[0].getMethodName(),
				(new Throwable()).getStackTrace()[0].getLineNumber(),
				"基本パラメータのチェック開始", 1, false);

		Context fromContext = SmacTracking.context;

		boolean result = true;

		if (fromContext == null) {
			/** ################# errorlog チェック false ################# */
			SmacUtils.recordLog(className,
					(new Throwable()).getStackTrace()[0].getMethodName(),
					(new Throwable()).getStackTrace()[0].getLineNumber(),
					"コンストラクターを引数に設定してください。", 2, false);
			result = false;
		}
		if (SmacTracking.intent == null) {
			/** ################# errorlog チェック false ################# */
			SmacUtils.recordLog(className,
					(new Throwable()).getStackTrace()[0].getMethodName(),
					(new Throwable()).getStackTrace()[0].getLineNumber(),
					"インテントを引数に設定してください。", 2, false);
			result = false;
		}

		if (smacMv != null && "".equals(smacMv)) {
			/** ################# errorlog チェック false ################# */
			SmacUtils.recordLog(className,
					(new Throwable()).getStackTrace()[0].getMethodName(),
					(new Throwable()).getStackTrace()[0].getLineNumber(),
					"MVが設定されていません。", 2, false);
			result = false;
		}
		if (TextUtils.isEmpty(siteId)) {
			/** ################# errorlog チェック false ################# */
			SmacUtils.recordLog(className,
					(new Throwable()).getStackTrace()[0].getMethodName(),
					(new Throwable()).getStackTrace()[0].getLineNumber(),
					"SiteIDを引数に設定してください。 ", 2, false);
			result = false;
		}

		if (fromContext
				.checkCallingOrSelfPermission(android.Manifest.permission.INTERNET) != PackageManager.PERMISSION_GRANTED) {
			/** ################# errorlog チェック false ################# */
			SmacUtils.recordLog(className,
					(new Throwable()).getStackTrace()[0].getMethodName(),
					(new Throwable()).getStackTrace()[0].getLineNumber(),
					"AndroidManifest.xml に INTERNET のパーミッションを追加してください。 ", 2,
					false);
			result = true;
		}

		if (fromContext
				.checkCallingOrSelfPermission(android.Manifest.permission.ACCESS_NETWORK_STATE) != PackageManager.PERMISSION_GRANTED) {
			/** ################# errorlog チェック false ################# */
			SmacUtils
					.recordLog(
							className,
							(new Throwable()).getStackTrace()[0]
									.getMethodName(),
							(new Throwable()).getStackTrace()[0]
									.getLineNumber(),
							"AndroidManifest.xml に ACCESS_NETWORK_STATE のパーミッションを追加してください。 ",
							2, false);
			result = true;
		}

		/** ################# tracelog 処理終了 ################# */
		SmacUtils.recordLog(className,
				(new Throwable()).getStackTrace()[0].getMethodName(),
				(new Throwable()).getStackTrace()[0].getLineNumber(),
				"基本パラメータのチェック終了", 1, false);

		return result;

	}

	/**
	 * CPI計測用パラメータのチェック
	 *
	 * @param fromContext
	 * @param fromIntent
	 * @param smacAppScheme
	 * @param smacAppHost
	 * @param smacMv
	 * @param siteId
	 * @param suid
	 * @return
	 */
	protected boolean checkParamsForCpi() {

		/** ################# tracelog 処理開始 ################# */
		SmacUtils.recordLog(className,
				(new Throwable()).getStackTrace()[0].getMethodName(),
				(new Throwable()).getStackTrace()[0].getLineNumber(),
				"CPI計測用パラメータのチェック開始", 1, false);

		boolean result = checkBaseParams(SmacTracking.siteId, SmacTracking.smacMv);

		if(!SmacTracking.cvMode.equals("1") && SmacTracking.actionPoint.get("browser_up_flg").equals("1")){
			if (TextUtils.isEmpty(SmacTracking.smacAppScheme)) {
				/** ################# errorlog チェック false ################# */
				SmacUtils.recordLog(className,
						(new Throwable()).getStackTrace()[0].getMethodName(),
						(new Throwable()).getStackTrace()[0].getLineNumber(),
						"Smac用のschmeを引数に設定してください。 ", 2, false);
				result = false;
			}
			if (TextUtils.isEmpty(SmacTracking.smacAppHost)) {
				/** ################# errorlog チェック false ################# */
				SmacUtils.recordLog(className,
						(new Throwable()).getStackTrace()[0].getMethodName(),
						(new Throwable()).getStackTrace()[0].getLineNumber(),
						"Smac用のhostを引数に設定してください。 ", 2, false);
				result = false;
			}
		}

		/** ################# tracelog 処理終了 ################# */
		SmacUtils.recordLog(className,
				(new Throwable()).getStackTrace()[0].getMethodName(),
				(new Throwable()).getStackTrace()[0].getLineNumber(),
				"CPI計測用パラメータのチェック終了", 1, false);

		return result;

	}

	/**
	 * アプリ内計測情報保存用のパラメータチェック
	 *
	 * @param fromContext
	 * @param fromIntent
	 * @param mv
	 * @param verify
	 * @param suid
	 * @param siteId
	 * @param saveMax
	 * @param saveMode
	 * @return
	 */
	protected boolean checkParamasForAppSave(String smacMv, String siteId,
			Integer saveMax, Integer saveMode) {

		/** ################# tracelog 処理開始 ################# */
		SmacUtils.recordLog(className,
				(new Throwable()).getStackTrace()[0].getMethodName(),
				(new Throwable()).getStackTrace()[0].getLineNumber(),
				"アプリ内計測用パラメータのチェック開始", 1, false);

		boolean result = checkBaseParams(siteId, smacMv);

		/** ################# tracelog 処理終了 ################# */
		SmacUtils.recordLog(className,
				(new Throwable()).getStackTrace()[0].getMethodName(),
				(new Throwable()).getStackTrace()[0].getLineNumber(),
				"アプリ内計測用パラメータのチェック終了", 1, false);

		return result;

	}

	/**
	 * Android_ID取得
	 *
	 * @param Context
	 * @return Android Marcket Id
	 */
	protected String getAndroidId() {

		String res = android.provider.Settings.Secure.getString(
				SmacTracking.context.getContentResolver(),
				android.provider.Settings.Secure.ANDROID_ID);
		if (TextUtils.isEmpty(res)) {
			/** ################# tracelog ################# */
			SmacUtils.recordLog(className,
					(new Throwable()).getStackTrace()[0].getMethodName(),
					(new Throwable()).getStackTrace()[0].getLineNumber(),
					"AndroidIdなし", 1, false);
			return "";
		}

		return res;
	}

	/**
	 * 端末名取得
	 *
	 * @return Device Name
	 */
	protected String getPhoneName() {

		if (TextUtils.isEmpty(android.os.Build.MODEL)) {
			/** ################# tracelog ################# */
			SmacUtils.recordLog(className,
					(new Throwable()).getStackTrace()[0].getMethodName(),
					(new Throwable()).getStackTrace()[0].getLineNumber(),
					"端末名取得失敗", 1, false);
		}

		return android.os.Build.MODEL;
	}

	//
	/**
	 * OSバージョン取得
	 *
	 * @return OS Version
	 */
	protected String getOsVersion() {
		if (TextUtils.isEmpty(android.os.Build.VERSION.RELEASE)) {
			/** ################# tracelog ################# */
			SmacUtils.recordLog(className,
					(new Throwable()).getStackTrace()[0].getMethodName(),
					(new Throwable()).getStackTrace()[0].getLineNumber(),
					"OSバージョン取得失敗", 1, false);
		}
		return android.os.Build.VERSION.RELEASE;
	}

	/**
	 * APIバージョン取得
	 *
	 * @return API Version
	 */
	protected int getApiVersion() {

		int ver = 0;
		try {
			ver = android.os.Build.VERSION.SDK_INT;
		} catch (Exception e) {
			/** ################# errorlog チェック false ################# */
			SmacUtils.recordErrorLog(className,
					(new Throwable()).getStackTrace()[0].getMethodName(),
					(new Throwable()).getStackTrace()[0].getLineNumber(),
					"APIバージョン取得の取得失敗 ", 2, false, e);
		}

		return ver;
	}

	/**
	 * Smac User-Agent作成
	 *
	 * @param Context
	 * @return User-Agent
	 */
	protected String makeUserAgent() {

		String ua = "";

		try {
			Context context = SmacTracking.context;
			String packegeName = context.getPackageName();

			PackageInfo packageInfo = context.getPackageManager()
					.getPackageInfo(packegeName, PackageManager.GET_META_DATA);
			ua = context.getPackageName() + "/" + packageInfo.versionName
					+ " Smac/" + smacConst.SDK_VERSION + " (Android) "
					+ Locale.getDefault().getCountry();
		} catch (NameNotFoundException e) {
			/** ################# errorlog チェック false ################# */
			SmacUtils.recordErrorLog(className,
					(new Throwable()).getStackTrace()[0].getMethodName(),
					(new Throwable()).getStackTrace()[0].getLineNumber(),
					"SDKバージョン取得の取得失敗 ", 2, false, e);
		}
		return ua;
	}

	/**
	 * ネットワーク状態取得
	 *
	 * @param Context
	 * @return bool
	 */
	protected boolean getNetworkStatus() {

		ConnectivityManager cm = (ConnectivityManager) SmacTracking.context
				.getApplicationContext().getSystemService(
						Context.CONNECTIVITY_SERVICE);
		NetworkInfo ni = cm.getActiveNetworkInfo();
		if (ni == null || cm.getActiveNetworkInfo().isConnected() == false) {
			/** ################# tracelog ################# */
			SmacUtils.recordLog(className,
					(new Throwable()).getStackTrace()[0].getMethodName(),
					(new Throwable()).getStackTrace()[0].getLineNumber(),
					"ネットワーク状態：未接続", 1, false);
			return false;
		} else {
			/** ################# tracelog ################# */
			SmacUtils.recordLog(className,
					(new Throwable()).getStackTrace()[0].getMethodName(),
					(new Throwable()).getStackTrace()[0].getLineNumber(),
					"ネットワーク状態：接続中", 1, false);
			return true;
		}

	}

	/**
	 * Smacへ接続できる状態か取得
	 *
	 * @return bool
	 */
	protected boolean checkNetworkStatus() {

		/** ################# tracelog ################# */
		SmacUtils.recordLog(className,
				(new Throwable()).getStackTrace()[0].getMethodName(),
				(new Throwable()).getStackTrace()[0].getLineNumber(),
				"Smacとの疎通確認開始", 1, false);

		boolean isConnected = true;

		// HttpHeadで接続チェック
		try {
			HttpParams httpParms = new BasicHttpParams();
			httpParms.setIntParameter(AllClientPNames.CONNECTION_TIMEOUT, 3000);
			httpParms.setIntParameter(AllClientPNames.SO_TIMEOUT, 3000);
			DefaultHttpClient client = new DefaultHttpClient(httpParms);
			HttpHead httpHead = new HttpHead(smacConst.HTTP_PATH_HEARTBEAT);
			HttpResponse response = client.execute(httpHead);

			// ステータスコードを取得
			int httpStatusCode = response.getStatusLine().getStatusCode();

			// HTTP Statusが200でない場合、Smac接続不可
			if (httpStatusCode != HttpStatus.SC_OK) {
				/** ################# tracelog ################# */
				SmacUtils.recordLog(className,
						(new Throwable()).getStackTrace()[0].getMethodName(),
						(new Throwable()).getStackTrace()[0].getLineNumber(),
						"Smacとの疎通確認：HTTPステータスエラー " + httpStatusCode, 1, false);

				isConnected = false;
			}
		} catch (Exception e) {
			/** ################# errorlog チェック false ################# */
			SmacUtils.recordErrorLog(className,
					(new Throwable()).getStackTrace()[0].getMethodName(),
					(new Throwable()).getStackTrace()[0].getLineNumber(),
					"Smacとの疎通確認失敗 ", 2, false, e);
			isConnected = false;
		}

		/** ################# tracelog ################# */
		SmacUtils.recordLog(className,
				(new Throwable()).getStackTrace()[0].getMethodName(),
				(new Throwable()).getStackTrace()[0].getLineNumber(),
				"Smacとの疎通確認完了", 1, false);

		return isConnected;
	}

	/**
	 * AES128暗号化
	 *
	 * @param data
	 *            暗号化の対象データ
	 * @param secret_key
	 *            128ビットの秘密鍵
	 * @return 暗号化されたデータ
	 */
	protected byte[] encodeAES128(byte[] data, byte[] secret_key) {

		/** ################# tracelog ################# */
		SmacUtils.recordLog(className,
				(new Throwable()).getStackTrace()[0].getMethodName(),
				(new Throwable()).getStackTrace()[0].getLineNumber(),
				"AES128暗号化開始", 1, false);

		byte[] returnByte = null;

		SecretKeySpec sKey = new SecretKeySpec(secret_key, "AES");
		try {
			Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
			cipher.init(Cipher.ENCRYPT_MODE, sKey);

			returnByte = cipher.doFinal(data);
			/** ################# tracelog ################# */
			SmacUtils.recordLog(className,
					(new Throwable()).getStackTrace()[0].getMethodName(),
					(new Throwable()).getStackTrace()[0].getLineNumber(),
					"AES128暗号化成功", 1, false);
		} catch (Exception e) {
			/** ################# errorlog チェック false ################# */
			SmacUtils.recordErrorLog(className,
					(new Throwable()).getStackTrace()[0].getMethodName(),
					(new Throwable()).getStackTrace()[0].getLineNumber(),
					"AES128暗号化失敗 ", 2, false, e);
		}

		/** ################# tracelog ################# */
		SmacUtils.recordLog(className,
				(new Throwable()).getStackTrace()[0].getMethodName(),
				(new Throwable()).getStackTrace()[0].getLineNumber(),
				"AES128暗号化完了", 1, false);

		return returnByte;
	}

	/**
	 * ZIP圧縮
	 *
	 * @param val
	 *            圧縮対象のデータ
	 * @return 圧縮されたデータ
	 */
	protected byte[] compressZip(String val) {

		/** ################# tracelog ################# */
		SmacUtils.recordLog(className,
				(new Throwable()).getStackTrace()[0].getMethodName(),
				(new Throwable()).getStackTrace()[0].getLineNumber(),
				"ZIP圧縮開始", 1, false);

		byte[] value = null;
		try {
			Deflater compresser = new Deflater();
			compresser.setLevel(Deflater.BEST_COMPRESSION);

			value = val.toString().getBytes();

			compresser.setInput(value);
			compresser.finish();

			ByteArrayOutputStream compos = new ByteArrayOutputStream(
					value.length);

			byte[] buf = new byte[1024];
			int count;
			while (!compresser.finished()) {
				count = compresser.deflate(buf);
				compos.write(buf, 0, count);
			}
			/** ################# tracelog ################# */
			SmacUtils.recordLog(className,
					(new Throwable()).getStackTrace()[0].getMethodName(),
					(new Throwable()).getStackTrace()[0].getLineNumber(),
					"ZIP圧縮成功", 1, false);
		} catch (Exception e) {
			/** ################# errorlog チェック false ################# */
			SmacUtils.recordErrorLog(className,
					(new Throwable()).getStackTrace()[0].getMethodName(),
					(new Throwable()).getStackTrace()[0].getLineNumber(),
					"ZIP圧縮失敗 ", 2, false, e);
		}

		/** ################# tracelog ################# */
		SmacUtils.recordLog(className,
				(new Throwable()).getStackTrace()[0].getMethodName(),
				(new Throwable()).getStackTrace()[0].getLineNumber(),
				"ZIP圧縮完了", 1, false);

		return value;
	}

	/**
	 * LZW圧縮
	 *
	 * @param uncompressed
	 *            圧縮対象のデータ
	 * @return 圧縮されたバイナリデータのバイトコード
	 */
	protected byte[] compressLzw(String uncompressed) {

		/** ################# tracelog ################# */
		SmacUtils.recordLog(className,
				(new Throwable()).getStackTrace()[0].getMethodName(),
				(new Throwable()).getStackTrace()[0].getLineNumber(),
				"LZW圧縮処理開始", 1, false);

		byte[] lzwByte = null;

		try {

			int dictSize = 256;
			Map<String, Integer> dictionary = new HashMap<String, Integer>();
			for (int i = 0; i < 256; i++) {
				dictionary.put("" + (char) i, i);
			}

			String w = "";
			List<Integer> codes = new ArrayList<Integer>();
			for (char c : uncompressed.toCharArray()) {
				String wc = w + c;
				if (dictionary.containsKey(wc)) {
					w = wc;
				} else {
					codes.add(dictionary.get(w));
					dictionary.put(wc, dictSize++);
					w = "" + c;
				}
			}

			if (!w.equals("")) {
				codes.add(dictionary.get(w));
			}

			int dictionary_count = 256;
			int bits = 8;
			List<Integer> asciiList = new ArrayList<Integer>();
			int rest = 0;
			int rest_length = 0;

			for (Integer code : codes) {
				rest = (rest << bits) + code;
				rest_length += bits;
				dictionary_count++;
				if (dictionary_count > (1 << bits)) {
					bits++;
				}

				while (rest_length > 7) {
					rest_length -= 8;
					asciiList.add((rest >> rest_length));
					rest &= (1 << rest_length) - 1;
				}
			}

			if (rest_length > 0) {
				asciiList.add((rest << (8 - rest_length)));
			}

			byte[] returnByte = new byte[asciiList.size()];
			for (int i = 0; i < asciiList.size(); i++) {
				returnByte[i] = asciiList.get(i).byteValue();
			}

			/** ################# tracelog ################# */
			SmacUtils.recordLog(className,
					(new Throwable()).getStackTrace()[0].getMethodName(),
					(new Throwable()).getStackTrace()[0].getLineNumber(),
					"LZW圧縮完了", 1, false);

			lzwByte = returnByte;

		} catch (Exception e) {
			/** ################# tracelog ################# */
			SmacUtils.recordErrorLog(className,
					(new Throwable()).getStackTrace()[0].getMethodName(),
					(new Throwable()).getStackTrace()[0].getLineNumber(),
					"LZW圧縮失敗", 2, false, e);
		}

		/** ################# tracelog ################# */
		SmacUtils.recordLog(className,
				(new Throwable()).getStackTrace()[0].getMethodName(),
				(new Throwable()).getStackTrace()[0].getLineNumber(),
				"LZW圧縮処理完了", 1, false);

		return lzwByte;

	}

	/** Base64テーブル */
	private static final String _BASE64_TABLE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

	/**
	 * Base64 エンコード
	 *
	 * @param data
	 *            対象データ
	 * @return Base64エンコードされたデータ
	 */
	protected String base64Encode(byte[] data) {

		/** ################# tracelog ################# */
		SmacUtils.recordLog(className,
				(new Throwable()).getStackTrace()[0].getMethodName(),
				(new Throwable()).getStackTrace()[0].getLineNumber(),
				"Base64 エンコード処理開始", 1, false);

		String returnStr = "";

		try {
			if (data.length == 0) {
				/** ################# tracelog ################# */
				SmacUtils.recordLog(className,
						(new Throwable()).getStackTrace()[0].getMethodName(),
						(new Throwable()).getStackTrace()[0].getLineNumber(),
						"Base64 エンコード処理終了:空文字", 1, false);
				return "";
			}

			int i;
			int index[] = new int[1 + data.length * 4 / 3];
			int count = 0;
			int limit = data.length - 3;
			int mod;
			int padding;
			StringBuilder result = new StringBuilder("");

			for (i = 0; i < limit; i += 3) {
				index[count++] = (data[i] & 0xfc) >>> 2;
				index[count++] = ((data[i] & 0x03) << 4)
						+ ((data[i + 1] & 0xf0) >>> 4);
				index[count++] = ((data[i + 1] & 0x0f) << 2)
						+ ((data[i + 2] & 0xc0) >>> 6);
				index[count++] = ((data[i + 2]) & 0x3f);
			}

			mod = data.length % 3;
			if (mod == 0) {
				index[count++] = (data[i] & 0xfc) >>> 2;
				index[count++] = ((data[i] & 0x03) << 4)
						+ ((data[i + 1] & 0xf0) >>> 4);
				index[count++] = ((data[i + 1] & 0x0f) << 2)
						+ ((data[i + 2] & 0xc0) >>> 6);
				index[count++] = ((data[i + 2]) & 0x3f);

			} else if (mod == 1) {
				index[count++] = (data[i] & 0xfc) >>> 2;
				index[count++] = (data[i] & 0x03) << 4;

			} else if (mod == 2) {
				index[count++] = (data[i] & 0xfc) >>> 2;
				index[count++] = ((data[i] & 0x03) << 4)
						+ ((data[i + 1] & 0xf0) >>> 4);
				index[count++] = (data[i + 1] & 0x0f) << 2;
			}

			for (i = 0; i < count; i++) {
				result.append(_BASE64_TABLE.charAt(index[i]));
			}

			padding = (4 - result.length() % 4) % 4;
			for (i = 0; i < padding; i++) {
				result.append("=");
			}

			returnStr = result.toString();
		} catch (Exception e) {
			/** ################# tracelog ################# */
			SmacUtils.recordErrorLog(className,
					(new Throwable()).getStackTrace()[0].getMethodName(),
					(new Throwable()).getStackTrace()[0].getLineNumber(),
					"Base64 エンコード失敗", 2, false, e);
		}

		/** ################# tracelog ################# */
		SmacUtils.recordLog(className,
				(new Throwable()).getStackTrace()[0].getMethodName(),
				(new Throwable()).getStackTrace()[0].getLineNumber(),
				"Base64 エンコード処理終了", 1, false);

		return returnStr;
	}

	/**
	 * Base64 デコード
	 *
	 * @param base64
	 *            Base64エンコードされたデータ
	 * @return データ
	 */
	protected byte[] base64Decode(String s) {

		/** ################# tracelog ################# */
		SmacUtils.recordLog(className,
				(new Throwable()).getStackTrace()[0].getMethodName(),
				(new Throwable()).getStackTrace()[0].getLineNumber(),
				"Base64 デコード処理開始" + s, 1, false);

		int end = 0; // end state
		if (s.endsWith("=")) {
			end++;
		}
		if (s.endsWith("==")) {
			end++;
		}
		int len = (s.length() + 3) / 4 * 3 - end;
		byte[] result = new byte[len];
		int dst = 0;
		try {
			for (int src = 0; src < s.length(); src++) {
				int code = _BASE64_TABLE.indexOf(s.charAt(src));
				if (code == -1) {
					break;
				}
				switch (src % 4) {
				case 0:
					result[dst] = (byte) (code << 2);
					break;
				case 1:
					result[dst++] |= (byte) ((code >> 4) & 0x3);
					result[dst] = (byte) (code << 4);
					break;
				case 2:
					result[dst++] |= (byte) ((code >> 2) & 0xf);
					result[dst] = (byte) (code << 6);
					break;
				case 3:
					result[dst++] |= (byte) (code & 0x3f);
					break;
				}
			}
		} catch (ArrayIndexOutOfBoundsException e) {
			// 正常なので何もしない
			SmacUtils.recordLog(className,
					(new Throwable()).getStackTrace()[0].getMethodName(),
					(new Throwable()).getStackTrace()[0].getLineNumber(),
					"Base64 デコード処理終了", 1, false);
		} catch (Exception ex) {
			/** ################# tracelog ################# */
			SmacUtils.recordLog(className,
					(new Throwable()).getStackTrace()[0].getMethodName(),
					(new Throwable()).getStackTrace()[0].getLineNumber(),
					"Base64 デコード処理エラー", 2, false);
		}
		/** ################# tracelog ################# */
		SmacUtils.recordLog(className,
				(new Throwable()).getStackTrace()[0].getMethodName(),
				(new Throwable()).getStackTrace()[0].getLineNumber(),
				"Base64 デコード処理終了", 1, false);
		return result;
	}

	/**
	 * ソケット通信でUUIDを取得
	 *
	 * @param context
	 * @return uuid
	 */
	protected String getUUID() {

		/** ################# tracelog ################# */
		SmacUtils.recordLog(className,
				(new Throwable()).getStackTrace()[0].getMethodName(),
				(new Throwable()).getStackTrace()[0].getLineNumber(),
				"UUID取得処理開始", 1, false);

		String uuid = null;

		try {
			SmacDBHelper dbHelper;
			dbHelper = new SmacDBHelper();
			// UUID取得
			HashMap<String, Object> userMap = dbHelper.selUser();
			dbHelper.close();
			if(userMap.get("UUID") != null){
				// DBにUUIDが入ってたらそれを返す
				return userMap.get("UUID").toString();
			}

			HttpPost httpPost = new HttpPost(smacConst.HTTP_PATH_UUID);

			List<NameValuePair> params = new ArrayList<NameValuePair>(1) {
				private static final long serialVersionUID = -2210805557550155321L;
				{
					add(new BasicNameValuePair("mode", "1"));
				}
			};
			httpPost.setEntity(new UrlEncodedFormEntity(params, "UTF-8"));
			httpPost.setHeader("User-Agent", makeUserAgent());

			HttpParams httpParms = new BasicHttpParams();
			httpParms.setIntParameter(AllClientPNames.CONNECTION_TIMEOUT, 3000);
			httpParms.setIntParameter(AllClientPNames.SO_TIMEOUT, 3000);
			DefaultHttpClient client = new DefaultHttpClient(httpParms);
			HttpResponse httpResponse = client.execute(httpPost);

			// ステータスコードを取得
			int httpStatusCode = httpResponse.getStatusLine().getStatusCode();

			// HTTP Statusが200の場合、正常通信
			if (httpStatusCode == HttpStatus.SC_OK) {

				// レスポンスを取得
				HttpEntity entity = httpResponse.getEntity();
				uuid = EntityUtils.toString(entity);

				// リソースを解放
				entity.consumeContent();

				// クライアントを終了させる
				client.getConnectionManager().shutdown();

				/** ################# tracelog ################# */
				SmacUtils.recordLog(className,
						(new Throwable()).getStackTrace()[0].getMethodName(),
						(new Throwable()).getStackTrace()[0].getLineNumber(),
						"UUID : " + uuid, 1, false);

			} else {
				/** ################# tracelog ################# */
				SmacUtils.recordLog(className,
						(new Throwable()).getStackTrace()[0].getMethodName(),
						(new Throwable()).getStackTrace()[0].getLineNumber(),
						"UUID未取得:[通信不可]", 1, false);
			}

		} catch (Exception e) {
			/** ################# tracelog ################# */
			SmacUtils.recordErrorLog(className,
					(new Throwable()).getStackTrace()[0].getMethodName(),
					(new Throwable()).getStackTrace()[0].getLineNumber(),
					"UUID取得失敗", 2, false, e);
		}

		/** ################# tracelog ################# */
		SmacUtils.recordLog(className,
				(new Throwable()).getStackTrace()[0].getMethodName(),
				(new Throwable()).getStackTrace()[0].getLineNumber(),
				"UUID取得処理終了", 1, false);

		return uuid;

	}

	/**
	 * ソケット通信で成果点情報を取得
	 *
	 * @param context
	 * @return uuid
	 */
	protected HashMap<String, String> getActionPoint(String mv) {

		/** ################# tracelog ################# */
		SmacUtils.recordLog(className,
				(new Throwable()).getStackTrace()[0].getMethodName(),
				(new Throwable()).getStackTrace()[0].getLineNumber(),
				"成果点情報取得処理開始", 1, false);

		String ret = null;
		HashMap<String, String> actionPointList = new HashMap<String, String>();

		try {
			HttpPost httpPost = new HttpPost(smacConst.HTTP_PATH_ACTION_POINT);

			List<NameValuePair> params = new ArrayList<NameValuePair>(2) {
				private static final long serialVersionUID = 7825567028420910212L;
			};
			params.add(new BasicNameValuePair("mv", mv));
			params.add(new BasicNameValuePair("dv", "a"));
			httpPost.setEntity(new UrlEncodedFormEntity(params, "UTF-8"));
			httpPost.setHeader("User-Agent", makeUserAgent());

			HttpParams httpParms = new BasicHttpParams();
			httpParms.setIntParameter(AllClientPNames.CONNECTION_TIMEOUT, 3000);
			httpParms.setIntParameter(AllClientPNames.SO_TIMEOUT, 3000);
			DefaultHttpClient client = new DefaultHttpClient(httpParms);
			HttpResponse httpResponse = client.execute(httpPost);

			// ステータスコードを取得
			int httpStatusCode = httpResponse.getStatusLine().getStatusCode();

			// HTTP Statusが200の場合、正常通信
			if (httpStatusCode == HttpStatus.SC_OK) {

				// レスポンスを取得
				HttpEntity entity = httpResponse.getEntity();
				ret = EntityUtils.toString(entity);

				// リソースを解放
				entity.consumeContent();

				// クライアントを終了させる
				client.getConnectionManager().shutdown();

			} else {
				/** ################# tracelog ################# */
				SmacUtils.recordLog(className,
						(new Throwable()).getStackTrace()[0].getMethodName(),
						(new Throwable()).getStackTrace()[0].getLineNumber(),
						"成果点情報未取得:[通信不可]", 1, false);
				return null;
			}

			if(ret.equals("result=-1")){
				/** ################# tracelog ################# */
				SmacUtils.recordErrorLog(className,
						(new Throwable()).getStackTrace()[0].getMethodName(),
						(new Throwable()).getStackTrace()[0].getLineNumber(),
						"成果点情報取得失敗 : エラーレスポンス -1", 2, false, null);
				return null;
			}

			String[] actionPointListArr = ret.split("&smac&");
			for (int i = 0; i < actionPointListArr.length; i++) {
				/** ################# tracelog ################# */
				SmacUtils.recordLog(className,
						(new Throwable()).getStackTrace()[0].getMethodName(),
						(new Throwable()).getStackTrace()[0].getLineNumber(),
						actionPointListArr[i], 1, false);
				String[] tmp = actionPointListArr[i].split("#");

				if (tmp.length == 1) {
					actionPointList.put(tmp[0], null);
				}

				if (tmp.length == 2) {
					if (tmp[0].equalsIgnoreCase("welcome_url")) {
						tmp[1] = new String(base64Decode(tmp[1]), "UTF-8");
					}
					actionPointList.put(tmp[0], tmp[1]);
				}
			}

		} catch (Exception e) {
			/** ################# tracelog ################# */
			SmacUtils.recordErrorLog(className,
					(new Throwable()).getStackTrace()[0].getMethodName(),
					(new Throwable()).getStackTrace()[0].getLineNumber(),
					"成果点情報取得失敗", 2, false, e);
			return null;
		}

		/** ################# tracelog ################# */
		SmacUtils.recordLog(className,
				(new Throwable()).getStackTrace()[0].getMethodName(),
				(new Throwable()).getStackTrace()[0].getLineNumber(),
				"成果点情報取得処理終了：" + ret, 1, false);

		return actionPointList;

	}

	/**
	 * ソケット通信(CPI用)
	 *
	 * @param url
	 *            通信先
	 * @param params
	 *            リクエストパラメータ
	 * @return bool
	 */
	protected boolean sendCpiBySocket(String url,
			ArrayList<NameValuePair> params) {

		/** ################# tracelog ################# */
		SmacUtils.recordLog(className,
				(new Throwable()).getStackTrace()[0].getMethodName(),
				(new Throwable()).getStackTrace()[0].getLineNumber(),
				"ソケット通信処理開始", 1, false);

		boolean res = false;

		try {
			HttpPost httpPost = new HttpPost(url);
			httpPost.setEntity(new UrlEncodedFormEntity(params, "UTF-8"));
			httpPost.setHeader("User-Agent", makeUserAgent());

			HttpParams httpParms = new BasicHttpParams();
			httpParms.setIntParameter(AllClientPNames.CONNECTION_TIMEOUT, 3000);
			httpParms.setIntParameter(AllClientPNames.SO_TIMEOUT, 3000);
			DefaultHttpClient client = new DefaultHttpClient(httpParms);
			HttpResponse httpResponse = client.execute(httpPost);

			// ステータスコードを取得
			int httpStatusCode = httpResponse.getStatusLine().getStatusCode();

			// HTTP Statusが200の場合、正常通信
			if (httpStatusCode == HttpStatus.SC_OK) {

				// レスポンスを取得
				HttpEntity entity = httpResponse.getEntity();
				String response = EntityUtils.toString(entity);

				// リソースを解放
				entity.consumeContent();

				// クライアントを終了させる
				client.getConnectionManager().shutdown();

				// レスポンスデーターチェック
				if ("1".equals(response)) {
					res = true;
				} else {
					/** ################# errorlog ################# */
					SmacUtils.recordLog(className, (new Throwable())
							.getStackTrace()[0].getMethodName(),
							(new Throwable()).getStackTrace()[0]
									.getLineNumber(), "ソケット通信処理失敗[エラーレスポンス] : "
									+ response, 2, false);
				}
			} else {
				/** ################# errorlog ################# */
				SmacUtils.recordLog(className,
						(new Throwable()).getStackTrace()[0].getMethodName(),
						(new Throwable()).getStackTrace()[0].getLineNumber(),
						"ソケット通信処理失敗[HTTPステータスエラー] : " + httpStatusCode, 2,
						false);
			}
		} catch (Exception e) {
			/** ################# errorlog ################# */
			SmacUtils.recordLog(className,
					(new Throwable()).getStackTrace()[0].getMethodName(),
					(new Throwable()).getStackTrace()[0].getLineNumber(),
					"ソケット通信処理失敗[Exception] : " + e, 2, false);
		}
		/** ################# tracelog ################# */
		SmacUtils.recordLog(className,
				(new Throwable()).getStackTrace()[0].getMethodName(),
				(new Throwable()).getStackTrace()[0].getLineNumber(),
				"ソケット通信処理終了", 1, false);

		return res;
	}

	private static final String twohyphens = "--";
	private static final String end = "\r\n";
	private static final String dq = "\"";
	private static final String prfx_boundary = "-----------------------------";
	private static final String mBoundary = prfx_boundary
			+ Long.toString(System.currentTimeMillis());

	/**
	 * ソケット通信(アプリ内計測用)
	 *
	 * @param url
	 *            通信先
	 * @param params
	 *            リクエストパラメータ
	 * @return bool
	 */
	protected boolean sendAppBySocket(String url, Map<String, String> params) {

		final String POST_METHOD = "POST";
		final String CONNECTION = "Connection";
		final String CHARSET = "Charset";
		final String CONTENT_TYPE = "Content-Type";

		final String KEEP_ALIVE = "Keep-Alive";
		final String UTF8 = "UTF-8";
		final String MULTIPART_BOUNDARY = "multipart/form-data; boundary=";

		final String FORM_LBL_OUTENC = "outputencoding";
		final String FORM_LBL_OUTFORMAT = "outputformat";
		final String FORM_LBL_USRFILE = "fs";
		final String FORM_LBL_ELEMENTCLASS = "eclass";
		final String FORM_VAL_FORMAT = "txt";
		final String FORM_VAL_FILE = "tmp_name";
		final String FORM_VAL_ELEMENTCLASS = "text_line";

		/** ################# tracelog ################# */
		SmacUtils.recordLog(className,
				(new Throwable()).getStackTrace()[0].getMethodName(),
				(new Throwable()).getStackTrace()[0].getLineNumber(),
				"ソケット通信処理開始", 1, false);

		boolean res = false;

		try {

			// コネクション開始

			URL conUrl = new URL(url);

			HttpURLConnection conn = (HttpURLConnection) conUrl
					.openConnection();
			conn.setDoOutput(true);
			conn.setDoInput(true);
			conn.setUseCaches(false);
			conn.setConnectTimeout(3000);
			conn.setReadTimeout(3000);

			// ヘッダ設定
			conn.setRequestMethod(POST_METHOD);

			conn.setRequestProperty(CONNECTION, KEEP_ALIVE);
			conn.addRequestProperty("User-Agent", makeUserAgent());
			conn.setRequestProperty(CHARSET, UTF8);
			conn.setRequestProperty(CONTENT_TYPE, MULTIPART_BOUNDARY
					+ mBoundary);

			// 送信データの設定
			DataOutputStream os = new DataOutputStream(conn.getOutputStream());

			// テキストフィールド
			append_string(os, FORM_LBL_OUTENC, UTF8.toLowerCase());
			append_string(os, FORM_LBL_OUTFORMAT, FORM_VAL_FORMAT);
			append_string(os, FORM_LBL_ELEMENTCLASS, FORM_VAL_ELEMENTCLASS);
			append_string(os, "sz", Integer.toString(params.get("fs").length()));

			// ファイルフィールド
			os.writeBytes(twohyphens + mBoundary + end);
			os.writeBytes("Content-Disposition: form-data; name=" + dq
					+ FORM_LBL_USRFILE + dq + "; filename=" + dq
					+ FORM_VAL_FILE + dq + end);
			os.writeBytes("Content-Type: application/octet-stream" + end + end);
			os.write(params.get("fs").getBytes(), 0, params.get("fs").length());
			os.flush();
			os.writeBytes(end);
			os.writeBytes(twohyphens + mBoundary + twohyphens + end);

			// 結果受け取り
			final int responceCode = conn.getResponseCode();

			if (responceCode != HttpURLConnection.HTTP_OK) {
				throw new RuntimeException("invalid responce code, "
						+ responceCode);
			}

			// 受信データ処理
			int httpStatusCode = conn.getResponseCode();

			// HTTP Statusが200の場合、正常通信
			if (httpStatusCode == HttpStatus.SC_OK) {

				// レスポンスを取得
				InputStream is = conn.getInputStream();// POSTした結果を取得
				BufferedReader reader = new BufferedReader(
						new InputStreamReader(is));
				// List<String> response = new ArrayList<String>();
				String resData = reader.readLine();

				// while ((resData = reader.readLine()) != null) {
				// response.add(resData);
				// }
				reader.close();

				// レスポンスデーターチェック
				if ("1".equals(resData)) {
					res = true;
				} else {
					/** ################# errorlog ################# */
					SmacUtils.recordLog(className, (new Throwable())
							.getStackTrace()[0].getMethodName(),
							(new Throwable()).getStackTrace()[0]
									.getLineNumber(), "ソケット通信処理失敗[エラーレスポンス] : "
									+ resData, 2, false);
				}
			} else {
				/** ################# errorlog ################# */
				SmacUtils.recordLog(className,
						(new Throwable()).getStackTrace()[0].getMethodName(),
						(new Throwable()).getStackTrace()[0].getLineNumber(),
						"ソケット通信処理失敗[HTTPステータスエラー] : " + httpStatusCode, 2,
						false);
			}
		} catch (Exception e) {
			/** ################# errorlog ################# */
			SmacUtils.recordErrorLog(className,
					(new Throwable()).getStackTrace()[0].getMethodName(),
					(new Throwable()).getStackTrace()[0].getLineNumber(),
					"ソケット通信処理失敗[Exception] : ", 2, false, e);
		}
		/** ################# tracelog ################# */
		SmacUtils.recordLog(className,
				(new Throwable()).getStackTrace()[0].getMethodName(),
				(new Throwable()).getStackTrace()[0].getLineNumber(),
				"ソケット通信処理終了", 1, false);

		return res;
	}

	private void append_string(DataOutputStream os, String name, String value)
			throws IOException {
		os.writeBytes(twohyphens + mBoundary + end);
		os.writeBytes("Content-Disposition: form-data; name=" + dq + name + dq
				+ end + end);
		os.writeBytes(value + end);
	}

	/**
	 * ブラウザからの起動かチェックする
	 *
	 * @return true : ブラウザから起動 / false : それ以外
	 */
	protected boolean isStartupFromBrowser() {

		/** ################# tracelog 処理開始 ################# */
		SmacUtils.recordLog(className,
				(new Throwable()).getStackTrace()[0].getMethodName(),
				(new Throwable()).getStackTrace()[0].getLineNumber(),
				"ブラウザ起動チェック処理開始", 1, false);

		boolean isTrue = false;

		try {

			Intent fromIntent = SmacTracking.intent;

			// ブラウザーから起動された場合
			String action = fromIntent.getAction();
			if (Intent.ACTION_VIEW.equals(action)) {

				/** ################# tracelog ################# */
				SmacUtils.recordLog(className, (new Throwable())
						.getStackTrace()[0].getMethodName(),
						(new Throwable()).getStackTrace()[0]
								.getLineNumber(), "ブラウザ起動チェック[ブラウザから起動]",
						1, false);

				Uri uri = fromIntent.getData();
				String q_sceme = "";
				String q_host = "";
				if (uri.getScheme() != null) {
					q_sceme = uri.getScheme();
				}
				if (uri.getHost() != null) {
					q_host = uri.getHost();
				}

				// schemeチェック
				if (SmacTracking.scheme.equals(q_sceme)
						&& SmacTracking.appHost.equals(q_host)) {
					isTrue = true;
					/** ################# tracelog ################# */
					SmacUtils.recordLog(className, (new Throwable())
							.getStackTrace()[0].getMethodName(),
							(new Throwable()).getStackTrace()[0]
									.getLineNumber(), "ブラウザ起動チェック[ブラウザから起動]",
							1, false);
				}
			} else {
				/** ################# tracelog ################# */
				SmacUtils.recordLog(className, (new Throwable())
						.getStackTrace()[0].getMethodName(),
						(new Throwable()).getStackTrace()[0]
								.getLineNumber(), "ブラウザ起動チェック[通常起動]", 1,
						false);
			}
		} catch (Exception e) {
			isTrue = false;
			/** ################# errorlog 処理失敗 ################# */
			SmacUtils.recordErrorLog(className,
					(new Throwable()).getStackTrace()[0].getMethodName(),
					(new Throwable()).getStackTrace()[0].getLineNumber(),
					"ブラウザ起動チェック失敗 : ", 2, false, e);
		}

		/** ################# tracelog 処理終了 ################# */
		SmacUtils.recordLog(className,
				(new Throwable()).getStackTrace()[0].getMethodName(),
				(new Throwable()).getStackTrace()[0].getLineNumber(),
				"ブラウザ起動チェック処理終了", 1, false);

		return isTrue;
	}

	/**
	 * SDカードにsqliteファイルをコピー
	 *
	 * @param fromContext
	 * @param intent
	 * @param srcFile
	 *            コピー元ファイル
	 * @param dstFile
	 *            コピー先ディレクトリ
	 */
	protected boolean copyDBtoExternalStorage() {

		// // PCでマウント中だったら強制的にマウント解除
		// if(Environment.MEDIA_SHARED.equals(Environment.getExternalStorageState())){
		// IMountService mountService =
		// IMountService.Stub.asInterface(fromContext.getSystemService(fromContext.));
		//
		// }

		boolean isSucceed = false;
		try {

			if (Environment.MEDIA_MOUNTED.equals(Environment
					.getExternalStorageState())) {

				String packageName = SmacTracking.intent.getComponent()
						.getPackageName();

				String sqlitePath = "/data/data/" + packageName + "/databases/"
						+ SmacConst.DB_NAME;

				File saveDir = new File(Environment
						.getExternalStorageDirectory().getPath()
						+ "/"
						+ packageName);
				saveDir.mkdirs();
				File saveFile = new File(saveDir.getPath() + "/"
						+ SmacConst.DB_NAME);
				if (saveFile.exists()) {
					// 存在する場合は消去
					saveFile.delete();
				}
				saveFile.createNewFile();

				InputStream input = null;
				OutputStream output = null;
				input = new FileInputStream(new File(sqlitePath));
				output = new FileOutputStream(saveFile, true);

				int DEFAULT_BUFFER_SIZE = 1024 * 4;
				byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
				int n = 0;
				while (-1 != (n = input.read(buffer))) {
					output.write(buffer, 0, n);
				}
				input.close();
				output.close();

				isSucceed = true;
			}

		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (Exception e) {
			e.printStackTrace();
		}

		return isSucceed;
	}

	/**
	 * sesidをファイルに書き込み
	 *
	 * @param sesid
	 * @return 書き込みできたらtrue
	 */
	protected static boolean writeSesid(Context context, String sesid) {
		/** ################# tracelog 処理開始 ################# */
		SmacUtils.recordLog(new SmacUtils().getClass().getSimpleName(),
				(new Throwable()).getStackTrace()[0].getMethodName(),
				(new Throwable()).getStackTrace()[0].getLineNumber(),
				"sesid書き込み開始 : " + sesid, 1, false);

		try {
			FileOutputStream fileOutputStream = context.openFileOutput(
					"sesid.txt", Context.MODE_PRIVATE);
			fileOutputStream.write(sesid.getBytes());
		} catch (Exception e) {
			e.printStackTrace();
			return false;
		}
		return true;
	}

	/**
	 * sesidをファイルから読み込み
	 *
	 * @return context
	 */
	protected static String readSesid(Context context) {
		try {
			FileInputStream fileInputStream;
			fileInputStream = context.openFileInput("sesid.txt");
			byte[] readBytes = new byte[fileInputStream.available()];
			fileInputStream.read(readBytes);
			String readString = new String(readBytes);
			/** ################# tracelog 処理開始 ################# */
			SmacUtils.recordLog(new SmacUtils().getClass().getSimpleName(),
					(new Throwable()).getStackTrace()[0].getMethodName(),
					(new Throwable()).getStackTrace()[0].getLineNumber(),
					"sesid読み込み : " + readString, 1, false);
			return readString;
		} catch (Exception e) {
			/** ################# errorlog ################# */
			SmacUtils.recordErrorLog(new SmacUtils().getClass().getSimpleName(),
					(new Throwable()).getStackTrace()[0].getMethodName(),
					(new Throwable()).getStackTrace()[0].getLineNumber(),
					"sesid読み込み失敗 : ", 2, false, e);
			return null;
		}
	}

	/**
	 * エラーログを記録
	 *
	 * @param className
	 * @param methodName
	 * @param raw
	 * @param message
	 * @param mode
	 * @param isInit
	 * @param e
	 */
	protected static void recordErrorLog(String className, String methodName,
			int raw, String message, int mode, boolean isInit, Exception e) {

		SmacConst smacConst = new SmacConst();

		StringBuilder exception = new StringBuilder();
		if (e != null && e.getStackTrace().length > 0) {

			exception.append(smacConst.CODE_LF).append("[StackTraceSection]")
					.append(smacConst.CODE_LF);

			for (int i = 0; i < e.getStackTrace().length; i++) {
				exception.append(e.getStackTrace()[i].toString()).append(
						smacConst.CODE_LF);
			}
		}
		recordLog(className, methodName, raw, message + exception, mode, isInit);
		if(e != null){
			e.printStackTrace();
		}
	}

	/**
	 * ログを記録
	 *
	 * @param fileName
	 * @param className
	 * @param methodName
	 * @param raw
	 * @param message
	 * @param mode
	 *            1:traceLog / 1以外:errorLog
	 * @param isInit
	 *            初期化モード
	 * @param mode
	 *            1:traceLog / 1以外:errorLog
	 */
	protected static void recordLog(String className, String methodName,
			int raw, String message, int mode, boolean isInit) {

		SmacConst smacConst = new SmacConst();

		// ログモードが無効な場合は記録しない
		if (SmacTracking.logMode != null && !SmacTracking.logMode) {
			return;
		}

		StringBuilder sb = new StringBuilder(512);

		sb.append(className).append(" ");
		sb.append(methodName).append(" ");
		sb.append(Integer.toString(raw)).append(" ");
		sb.append(message);

		if (sb.length() > 0) {
			// LogCat
			if (mode == 0) {
				Log.d(smacConst.LOG_SUCCESS_TAG, sb.toString());
			} else if (mode == 1) {
				Log.d(smacConst.LOG_TRACE_TAG, sb.toString());
			} else if (mode == 2) {
				Log.e(smacConst.LOG_ERROR_TAG, sb.toString());
			}

			// SDカードが有効な場合はログ出力
			if (SmacTracking.enableSDCard != null && SmacTracking.enableSDCard) {
				if (!logWriter(sb.toString(), mode, isInit)) {
					Log.d(smacConst.LOG_TRACE_TAG, "SDカードへの出力に失敗しました。");
				}
			}

		}
	}

	/**
	 * ログをSDカードに保存
	 *
	 * @param log
	 * @param mode
	 *            1:traceLog / 1以外:errorLog
	 * @param isInit
	 *            初期化モード
	 * @return true:writed / false:can't writed
	 */
	private static boolean logWriter(String log, int mode, boolean isInit) {

		SmacConst smacConst = new SmacConst();

		boolean isSucceed = false;

		try {

			if (Environment.MEDIA_MOUNTED.equals(Environment
					.getExternalStorageState())) {

				String packageName = SmacTracking.intent.getComponent()
						.getPackageName();

				File saveDir = new File(Environment
						.getExternalStorageDirectory().getPath()
						+ "/"
						+ packageName);
				saveDir.mkdirs();
				File saveFile = new File(saveDir.getPath() + "/"
						+ smacConst.LOG_FILE_NAME);

				StringBuilder sb = new StringBuilder();

				// 初期化フラグがtrueの場合は初期化
				if (isInit) {
					saveFile.delete();
				}

				// ファイルが存在しない場合
				if (!saveFile.exists()) {

					// ファイル新規作成
					saveFile.createNewFile();

					// ヘッダ出力
					// header
					sb.append("[head]").append(smacConst.CODE_LF);
					sb.append("SDK Version : " + smacConst.SDK_VERSION).append(
							smacConst.CODE_LF);
					sb.append(smacConst.CODE_LF);
				}

				BufferedWriter bufferedWriterObj = null;
				// ファイル出力ストリームの作成
				bufferedWriterObj = new BufferedWriter(new OutputStreamWriter(
						new FileOutputStream(saveFile, true), "UTF-8"));

				SimpleDateFormat dateFormat = new SimpleDateFormat(
						"yyyy/MM/dd HH:mm:ss.SSS");
				String dateStr = dateFormat.format(System.currentTimeMillis());

				if (!TextUtils.isEmpty(log)) {

					if (mode == 0) {
						// successlog
						sb.append("[success] : ");
					} else if (mode == 1) {
						// tracelog
						sb.append("[trace] : ");
					} else if (mode == 2) {
						// errorlog
						sb.append("[error] : ");
					}
					sb.append(dateStr).append(smacConst.CODE_TAB);
					sb.append(log).append(smacConst.CODE_LF);
				}

				String logStr = null;
				if (sb.length() > 0) {
					logStr = sb.toString();
				}

				bufferedWriterObj.write(logStr);
				bufferedWriterObj.flush();

				isSucceed = true;
			} else {
				Log.d(smacConst.LOG_ERROR_TAG,
						"SDカードへの出力が出来ません。理由：SDカードが存在しない。又はSDカードがPCにマウントされている等");
			}
		} catch (Exception e) {
			e.printStackTrace();
		}

		return isSucceed;
	}

	/**
	 * 必要な処理を行ってからプロセスを落とす
	 *
	 */
	protected static void processKiller() {

		try {

			// 原因追求のため可能な場合はsqliteファイルをSDカードにコピー
			SmacUtils smacUtils = new SmacUtils();
			smacUtils.copyDBtoExternalStorage();

			/** ################# errorlog ################# */
			SmacUtils.recordLog(new SmacUtils().getClass().getSimpleName(),
					(new Throwable()).getStackTrace()[0].getMethodName(),
					(new Throwable()).getStackTrace()[0].getLineNumber(),
					"エラーによりプロセス終了 ", 2, false);
		} catch (Exception e) {

		} finally {
			Process.killProcess(Process.myPid());
		}
	}

}
